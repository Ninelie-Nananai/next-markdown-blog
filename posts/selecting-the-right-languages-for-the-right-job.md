---
title: "SELECTING THE “RIGHT” LANGUAGE FOR THE JOB"
date: 'March 5, 2022'
excerpt: 'เลือกภาษาที่ “ใช่” สำหรับงานที่ชอบ'
cover_image: '/images/posts/img3.jpg'
---

## SELECTING THE “RIGHT” LANGUAGE FOR THE JOB (การเลือกภาษาที่ “ใช่” สำหรับงานที่ชอบ)
### การมีประสบการณ์ในด้านนี้มีประโยชน์อย่างไรบ้าง? จะดีจริงมั้ยที่จะเราใช้เวลาไปกับการทำความคุ้นเคยกับภาษา OOP แทนที่จะไปเรียนรู้กระบวนการในมุมมองอื่นๆ? 
สำหรับใครที่อยากได้รับการพิจารณาให้เป็นผู้เชี่ยวชาญด้านซอฟต์แวร์ จำเป็นต้องรู้หลายภาษา และต้องเป็นภาษาที่ดี เรียนรู้การเขียนโปรแกรม ได้หลายภาษา อย่างไรก็ตาม การรู้เพียงแค่ C++ ภาษาเดียว หรือเพียงแค่รู้กระบวนการทำงานของกระบวนทัศน์ของภาษาเดียว ก็อาจเป็นเหมือนคนตาบอด หรือคนตาบอดสี: ซึ่งคุณแทบจะไม่รู้เลยว่าสิ่งที่คุณขาดหายไปนั่น คือแรงบันดาลใจที่ใช้ในการเขียนโปรแกรมที่ดี ซึ่งจะมาจากการเรียนรู้ การศึกษาการเขียนในรูปแบบต่างๆ และการใช้งานภาษาต่างๆ มามากมาย

ผมยังถือว่าการเขียนโปรแกรมนั้นไม่สำคัญ นั้นเป็นงานของมืออาชีพ และต้องมีการศึกษาในวงกว้าง ไม่ใช่แค่สำหรับคนที่มีงานยุ่งตลอดเวลา มันต้อง "ได้รับการฝึกฝน" ก่อนเท่านั้น

หากผู้พัฒนาไม่ได้รวมคอนสตรัคเตอร์ไว้ในคลาสแม่ ตอนคอมไพเลอร์ ให้รวมคอนสตรัคเตอร์ไว้คลาสย่อยแทนได้ โปรแกรมจะเรียกใช้คอนสตรัคเตอร์จากคลาสย่อยแทนถ้ามีอยู่

คลาสของสมาชิกสามารถตั้งเป็น Private หรือ Protect หรือเป็น Public ก็ได้ สมาชิก Private สามารถเข้าถึงได้โดยตัวของสมาชิกเอง และเมธอดต่างๆ ในคลาสตัวเองเท่านั้น คุณสมบัติมาตรฐานของสมาชิก และคุณสมบัติของคลาสต่างๆ สามารถประกาศให้มองเห็นได้ ในส่วนของสมาชิกแบบ Public สามารถมองเห็นได้ทุกที่ ส่วนสมาชิกที่เป็นแบบ Protect จะได้รับการป้องกันไว้และจะได้รับความสําคัญเสมือนสมาชิก Private แต่ยกเว้นในคลาสที่ได้รับการ Protect  คลาสที่ได้รับการ Protect สามารถปรับเปลี่ยนการเข้าถึงสำหรับสมาชิกที่สืบทอดมาได้ รูปแบบไวยากรณ์แบบเต็มของคลาสที่ได้รับการ Protect จะมีดังนี้:

```c++
class derived_class_name : derivation_mode base_class_name
{data member and member function declarations};
```

derivation_mode สามารถเป็นได้ทั้งแบบ Public และแบบ Private  (อย่าสับสนระหว่างคลาสแบบ Public และแบบ Private  กับสมาชิกแบบ Public และสมาชิกแบบ Private) สมาชิกแบบ Public และแบบ Private จะมีการ Protect ไว้ ในส่วนของคลาสพื้นฐานยังคงเป็นแบบ Public และได้รับการ Protect ตามลำดับในคลาสที่ได้รับจาก Public และในส่วนของสมาชิก Public และสมาชิกที่ได้รับการป้องกัน (Protect) ของคลาสพื้นฐานจะถือว่าเป็นคลาส Private  ดังนั้น ในลำดับชั้นของคลาส คลาส Private ที่ได้รับการ Protect  จะสามารถเพิกถอนการเข้าถึงจากคลาสที่สืบทอดมาได้ สมาชิก Private ที่ระดับทั่วไปจะสนใจเฉพาะคลาสที่สึบทอดมา แต่สมาชิกของคลาสที่ได้รับการ Protect จะมองไม่เห็น จึงไม่มีประโยชน์อะไรที่คลาส Private จะสามารถอนุญาตให้คลาสย่อยที่มีสมาชิกที่แตกต่างกันเข้าถึงได้ ต้องเป็นสมาชิกเดียวกันกับคลาสพาเรนต์เท่านั้น พิจารณาตัวอย่างต่อไปนี้:

สามารถ Protect ได้ แต่ไม่ได้กล่าวถึงในตัวอย่างนี้

```c++
class base_class {
    private:
        int a;
        float x;
    protected:
        int b;
        float y;
    public:
        int c;
        float z;
};
class subclass_1 : public base_class {. . .};
class subclass_2 : private base_class {. . .};
```

ใน subclass_1 b และ y ได้รับการ Protect  ในขณะที่ c และ z เป็น Public ใน subclass_2, b, y, c และ z เป็น Private ไม่มีคลาสที่ได้รับการ Protect  subclass_2 สามารถมีสมาชิกที่สามารถเข้าถึง base_class ได้ สมาชิกข้อมูล a และสมาชิกของ x ไม่สามารถเข้าถึง base_class ใน subclass_1 หรือ subclass_2 ได้

โปรดทราบว่าคลาสย่อยที่มาจาก Private ไม่สามารถเป็น Subtype ได้ ตัวอย่างเช่น ถ้าคลาสหลักมีสมาชิกข้อมูลเป็น Public ภายใต้การสีบทอดแบบ Private ข้อมูลนี้จะเป็นแบบ Private ในคลาสย่อยด้วย ดังนั้นจึงไม่สามารถเข้าถึงได้ หากต้องการเข้าถึงจากคลาสย่อย คลาสย่อยต้องแทนสมาชิกนั้นด้วยคลาสหลัก อย่างไรก็ตาม คลาสย่อยที่เปิดเป็น Public ไว้อาจเป็น Subtype ก็ได้ ซึ่งมักจะเป็น Subtype

สมาชิกของคลาสพาเรนต์ภายใต้การสืบทอดของคลาส Private สำหรับอินสแตนซ์ของคลาสจะไม่ปรากฏให้เห็นหากได้รับการ Protect ไว้ สมาชิกใดๆ ที่ต้องการทำให้มองเห็นได้ จะต้องถูกส่งออกไปยังคลาสที่สิบทอดก่อน ด้วยการส่งออกซ้ำนี้จะสามารถทำงานได้แม้ว่าจะเป็นแบบ Private ยกเว้นสมาชิกที่ถูกซ่อนอยู่ พิจารณาตัวอย่างการนิยามคลาสต่อไปนี้:

```c++
class subclass_3 : private base_class {
    base_class :: c;
    . . .
}
```

ตอนนี้ อินสแตนซ์ของ subclass_3 สามารถเข้าถึง c เท่าที่เกี่ยวข้องกับ c ราวกับว่าการสืบทอดนั้นเปิดแบบ Public โคลอนคู่ ( :: ) ในนิยามคลาสนี้คือตัวดำเนินการแก้ไขขอบเขต การเลือก Type ที่จะมีการกำหนดเอนทิตีดังต่อไปนี้

ตัวอย่างในย่อหน้าถัดไปจะแสดงวัตถุประสงค์ และการใช้คลาสแบบ Private

พิจารณาตัวอย่างการสืบทอด C++ ต่อไปนี้ ซึ่งมีการกำหนดคลาสรายการที่เชื่อมโยงแบบ Public จากนั้นยังใช้เพื่อการกำหนดคลาสย่อยที่มีอีก 2 คลาส:

```c++
class single_linked_list {
    private:
        class node {
        public:
            node *link;
            int contents;
        };
        node *head;
    public:
        single_linked_list() {head = 0};
        void insert_at_head(int);
        void insert_at_tail(int);
        int remove_at_head();
        int empty();
};
```

โหนดคลาสที่ซ้อนกัน จะกำหนดเซลล์ของรายการที่เชื่อมโยงกันให้ประกอบไปด้วยตัวแปรของจำนวนเต็ม และตัวชี้ไปยังออบเจ้กต์ที่โหนดนั้นๆ คลาสโหนดที่เป็น Private จะซ่อนจากคลาสอื่นทั้งหมด แม้สมาชิกของมันจะเป็น Public ก็ตาม คลาสที่ซ้อนกันสามารถมองเห็นได้ single_linked_list หากเป็น Private โหนดจะต้องประกาศคลาสซ้อนกันเพื่อให้คลาสที่ซ้อนอยู่สามารถมองเห็นได้ แต่ว่าคลาสที่ซ้อนกันจะไม่มีสิทธิ์ในการเข้าถึงสมาชิกของคลาสที่ซ้อนอยู่ เมธอดของคลาสที่ซ้อนกันจะมองเห็นได้เฉพาะสมาชิกข้อมูล Static ของคลาสที่ซ้อนอยู่เท่านั้น

> คลาสยังสามารถกำหนดได้ด้วยการซ้อนคลาส ขอบเขตสำหรับคลาสเหมือนกับคลาสที่ซ้อนกันโดยตรงภายในคลาสอื่น แม้กระทั่งสำหรับตัวแปรทั่วไปที่ประกาศในไว้คลาส

คลาสที่ล้อมรอบ single_linked_list จะมีสมาชิกข้อมูลเพียงตัวเดียว และตัวชี้เพื่อทำหน้าที่เป็นส่วนหัวของรายการชี้ไปยังตำแหน่งต่างๆ ประกอบด้วยฟังก์ชันคอนสตรัคเตอร์ ซึ่งเป็นการตั้งค่าส่วนหัวเป็นค่า null และฟังก์ชันสมาชิกที่ช่วยให้สามารถแทรกโหนดที่ปลายด้านใดด้านหนึ่งของรายการนั้นๆได้ เพื่อการทดสอบโหนดจะถูกลบออกจากปลายด้านหนึ่งของรายการ เพื่อดูว่าว่างเปล่าจริงหรือไม่

คลาสต่อไปนี้แสดงถึงคลาสสแต็ก และคิว ทั้งสองสืบทอดมาจากคลาส single_list:

```c++
class stack : public single_linked_list {
    public:
        stack() {}
        void push(int value) {
            insert_at_head(value);
        }
        int pop() {
            return remove_at_head();
        }
};
class queue : public single_linked_list {
    public:
        queue() {}
        void enqueue(int value) {
            insert_at_tail(value);
        }
        int dequeue() {
            remove_at_head();
        }
};
```

โปรดทราบว่าอ็อบเจ็กต์ของคลาสย่อยทั้งแบบสแต็ก และคิวสามารถเข้าถึงฟังก์ชันว่างเปล่าที่กำหนดไว้ในคลาสหลักได้ single_linked_list (เนื่องจากเป็นการสืบทอดแบบ Public) คลาสย่อยทั้งสองจะกำหนดฟังก์ชันคอนสตรัคเตอร์ที่ไม่ทำอะไรเลยเอาไว้ เมื่อออบเจ้กต์ของคลาสย่อยถูกสร้างขึ้น คอนสตรัคเตอร์ที่ตรงกันในคลาสย่อยจะถูกเรียกโดยปริยาย จากนั้น คอนสตรัคเตอร์ใดๆ ก็ตามในคลาสหลักจะถูกเรียกตาม ในตัวอย่างของเรา เมื่อมีการสร้างอ็อบเจ็กต์ประเภทสแต็กขึ้นมา คอนสตรัคเตอร์ใน single_linked_list จะถูกเรียก ซึ่งทำหน้าเป็นเมธอดเริ่มต้น จากนั้นตัวสร้างสแต็กจะถูกเรียกซึ่งไม่ทำอะไรเลย

จะเห็นว่าคลาสสแต็ก และคิวทั้งหมดมีปัญหาร้ายเหมือนกันอยู่: ไคลเอนต์ของทั้งสองสามารถเข้าถึงสมาชิก Public ทั้งหมดของคลาสพาเรนต์ได้ single_linked_list แต่ไคลเอนต์ของออบเจ้กต์สแต็กสามารถเรียก insert_at_tail ซึ่งเป็นการทำลายความสมบูรณ์ของสแต็ก ในทำนองเดียวกัน ไคลเอ็นต์ของอ็อบเจ็กต์คิวสามารถเรียก insert_at_head และอนุญาตให้เข้าถึงได้ เนื่องจากทั้งสแต็ก และคิวเป็นประเภทย่อยของ single_linked_list คลาส Public จะถูกเรียกใช้ก็ต่อเมื่อเราต้องการให้คลาสย่อยสืบทอดอินเทอร์เฟซทั้งหมดของคลาสหลัก อีกทางเลือกหนึ่งคือการใช้คลาสที่คลาสย่อยรับช่วงต่อจากคลาสหลักเท่านั้น คลาสที่ได้รับการสืบทอดมาดัง 2 ตัวอย่างสามารถเขียนเพื่อไม่ให้เป็นประเภทย่อยของคลาสพาเรนต์โดยใช้ **Private** แทนที่จะเป็น **Public** จากนั้นทั้ง 2 จะต้องเอ็กซ์พอร์ตค่าว่างเปล่าออกมาเพราะจะกลายเป็นว่า ถูกซ่อนอยู่ในอินสแตนซ์ซะเอง เกิดเป็นคำจำกัดความใหม่ของประเภทสแต็กและคิว ชื่อ stack_2 และ queue_2 ดังต่อไปนี้:

> สิ่งเหล่านี้ไม่ใช่ Subtype เนื่องจากไคลเอนต์สามารถเห็นสมาชิกเป็น Public จากคลาสพาเรนต์ได้ อย่างไรก็ตาม สมาชิกเหล่านี้ไม่ใช่ไคลเอนต์ของคลาสย่อยที่เป็น Private

```c++
class stack_2 : private single_linked_list {
    public:
        stack_2() {}
        void push(int value) {
            single_linked_list :: insert_at_head(value);
        }
        int pop() {
            return single_linked_list :: remove_at_head();
        }
        single_linked_list:: empty();
};
class queue_2 : private single_linked_list {
    public:
        queue_2() {}
        void enqueue(int value) {
            single_linked_list :: insert_at_tail(value);
        }
        int dequeue() {
            single_linked_list :: remove_at_head();
        }
        single_linked_list:: empty();
};
```

ทั้งสองคลาสใช้ re-exports เพื่อให้ไคลเอ็นต์สามารถเข้าถึงเมธอดของคลาสหลักได้ และจะไม่จำเป็นเมื่อใช้คลาสแบบ Public

ทั้ง 2 เวอร์ชัน สแตก และคิว แสดงความถึงความแตกต่างระหว่าง Subtype และ Type ที่สืบทอดมาที่ไม่ใช่ Subtype ออบเจ้กต์ที่เชื่อมโยงกันเป็นคุณลักษณะทั่วไปของ สแต็กและคิว เนื่องจากทั้งสองออบเจ้กต์สามารถใช้เป็นออบเจ้กต์ที่เชื่อมโยงกันได้ ดังนั้นจึงเป็นเรื่องธรรมดาที่จะสืบทอดมาจากคลาสออบเจ้กต์ที่เชื่อมโยงกันเพื่อกำหนดคลาสสแต็กและคิว แต่สิ่งเหล่านี้ไม่ใช่ Subtype ของคลาสที่เชื่อมโยงกัน ทั้งสองจะต้องทำให้สมาชิก Public ของคลาสแม่เป็น Private ก่อน ทำให้ไคลเอ็นต์ไม่สามารถเข้าถึงได้

เหตุผลหนึ่งที่ต้องการ "ให้เชื่อมกัน" คือต้องการเขียนโปรแกรมย่อยที่สามารถเข้าถึงสมาชิกของสองคลาสที่แตกต่างกันได้ ตัวอย่างเช่น สมมติว่าโปรแกรมใช้คลาสหนึ่งสำหรับ Vector และอีกคลาสหนึ่งสำหรับเมทริกซ์ และจำเป็นต้องใช้โปรแกรมย่อยในการคูณอบบเจ้กต์เมทริกซ์กับอบบเจ้กต์ Vector ใน C ++ ฟังก์ชันการคูณสามารถทำให้ทั้งสองคลาสเป็นเชื่อมกันได้

ดังที่กล่าวไว้ก่อนหน้านี้ C++ ใช้การสืบทอดหลายรายการ ตัวอย่างเช่น สมมติว่าเราต้องการคลาสสำหรับ Drawing ที่ต้องการการทำงานของคลาส Drawing และเมธอดคลาสใหม่ที่ต้องรันบน Thread เราสามารถกำหนดสิ่งต่อไปนี้ได้:

```c++
class Thread { . . . };
class Drawing { . . . };
class DrawThread : public Thread, public Drawing { . . . };
```

คลาส DrawThread จะสืบทอดสมาชิกทั้งหมดของทั้ง Thread และ Drawing ถ้าทั้ง Thread และ Drawing มีสมาชิกที่มีชื่อเหมือนกัน นอกจากนี้ยังสามารถอ้างอิงในออบเจ้กต์ของคลาส DrawThread โดยใช้ตัวดำเนินการแก้ไขขอบเขต ( :: ) ดังภาพ 12.5.

<div align="center">
    <img src="/images/posts/Multiple-inheritance.png"/>
    <p>
    Figure 12.5 Multiple inheritance (การสืบทอดหลายรายการ)
    </p>
</div>



ปัญหาบางอย่างที่เกี่ยวข้องกับการใช้การสืบทอดหลายรายการใน C++ ที่มีการกล่าวถึงในหัวข้อ 12.5

วิธีการแทนที่เมธอด 12 ใน C++ ต้องมีโปรไฟล์พารามิเตอร์เหมือนกันทุกประการและวิธีการแทนที่ เมธอดในคลาสย่อยถือว่าเป็นเมธอดใหม่ที่ไม่เกี่ยวข้องกับเมธอดที่มีชื่อเดียวกันในคลาสหลัก หากโปรไฟล์พารามิเตอร์ต่างกัน ชนิดการคืนค่าและวิธีการแทนที่ก็ต้องเปลี่ยนไปด้วยเหมือนกับชนิดที่จะคืนค่าไป หรือต้องเป็น Type ที่สืบทอดแบบ Public ของ Type ที่คืนค่าเมธอดที่ถูกแทนที่

>  จำไว้ว่าเมธอดที่ถูกแทนที่คือเมธอดที่กำหนดไว้ในคลาสที่สืบทอดมาเพื่อแทนที่เมธอดเดิม เสมือนการสืบทอดมาจากคลาสแม่ หากต้องส่งค่าให้ใช้วิธีการแทนที่แบบไดนามิก


## 12.4.2.3 Dynamic Binding (การเชื่อมโยงแบบไดนามิก)
ฟังก์ชั่นสมาชิกทั้งหมดที่เรากำหนดไว้จะเป็นการเชื่อมโยงแบบไดนามิก หมายความว่าการเรียกไปที่ตัวใดตัวหนึ่งในนั้น จะเป็นการกําหนดฟังก์ชั่นแบบสแตติก ออบเจ้กต์ C++ จะสามารถประมวลผลผ่านตัวแปลค่านั้นได้เลย แทนที่จะเป็นตัวชี้ หรือตัวอ้างถึง (ออบเจ้กต์ดังกล่าวจะเป็นสแตติกหรือสแต็กไดนามิก) ในกรณีนี้ประเภทของอ็อบเจ็กต์จะเป็นสแตติก ดังนั้นการเชื่อมโยงแบบไดนามิกจึงไม่จำเป็น ตัวแปรพอยน์เตอร์ที่มี Type ของคลาสหลักเก็บไว้สามารถใช้เพื่อชี้ไปยังอ็อบเจ็กต์ไดนามิกของคลาสใดๆ ที่เป็น Public จากคลาสหลักนั้นได้ ทำให้กลายเป็นตัวแปรแบบ polymorphic และคลาสย่อยที่สืบทอดมาแบบ Private จะไม่เป็น Subtype

C++ ไม่อนุญาตตัวแปรค่า (ตรงข้ามกับตัวชี้หรือการอ้างอิง) แม้เป็น polymorphic หากใช้ตัวแปร polymorphic เรียกสมาชิกของฟังก์ชันที่ถูกแทนที่ในคลาสที่สืบทอดมา ต้องเรียกผูกแบบไดนามิกกับฟังก์ชันที่กำหนดไว้ และต้องมีสมาชิกตรงกัน

พิจารณาภาพรวมของคลาสพื้นฐานที่เรียกว่า "Shape" และคอลเล็กชันของรูปทรงต่างๆ เช่น วงกลม สี่เหลี่ยมจัตุรัส ฯลฯ ก่อนแสดงรูปร่างเหล่านี้ออกไป ฟังก์ชัน Member จะแสดง draw ที่ไม่ซ้ำกับคลาสที่สืบทอดมา ด้วยการกำหนดให้ draw เวอร์ชันนี้เป็นแบบ virtual เมื่อทำการเรียกด้วยตัวชี้ไปยังคลาสหลักจากคลาสที่สืบทอดมา การเรียกนั้นจะต้องเชื่อมโยงกับฟังก์ชันสมาชิกของคลาสที่ได้รับการสืบทอดมาแบบไดนามิก ตัวอย่างต่อไปนี้มีคำจำกัดความโครงสร้างสำหรับตัวอย่างที่เพิ่งอธิบายไป:

```c++
class Shape {
    public:
        virtual void draw() = 0;
    . . .
};
class Circle : public Shape {
    public:
        void draw() { . . . }
    . . .
};
class Rectangle : public Shape {
    public:
        void draw() { . . . }
    . . .
};
```

จากคำจำกัดความเหล่านี้ โค้ดต่อไปจะมีตัวอย่างของการเรียกที่เชื่อมโยกกันแบบสแตติกและไดนามิก:

```c++
Circle* circ = new Circle;
Rectangle* rect = new Rectangle;
Shape* ptr_shape;
ptr_shape = circ;       // Now ptr_shape points to a
                        // Circle object
ptr_shape->draw();      // Dynamically bound to the draw
                        // in the Circle class
rect->draw();           // Statically bound to the draw
                        // in the Rectangle class
```

สถานการณ์นี้แสดงให้เห็นในรูปที่ 12.6.

<div align="center">
    <img src="/images/posts/Dynamic-binding.png"/>
    <p>
    Figure 12.6 Dynamic binding (การเชื่อมโยงแบบไดนามิก)
    </p>
</div>


รูปที่ 12.6 ข้อความแสดงแทนแบบเต็ม

สังเกตว่าฟังก์ชัน draw ที่ใช้ในการกำหนดรูปร่างของคลาสหลักจะถูกตั้งค่าเป็น 0 ด้วยไวยากรณ์แปลกๆ อันนี้ใช้เพื่อระบุว่าฟังก์ชันสมาชิกนี้เป็น **virtual function** ซึ่งหมายความว่าจะไม่มีเนื้อหาใดๆ และไม่สามารถเรียกใช้ได้ และจะต้องถูกกำหนดใหม่ในคลาสที่สืบทอดไปหากต้องการเรียกใช้ฟังก์ชัน จุดประสงค์ของ virtual function คือการจัดเตรียมอินเทอร์เฟซของฟังก์ชันโดยไม่ต้องดำเนินการใดๆ ก่อน  virtual function มักจะถูกกำหนดเมื่อฟังก์ชันสมาชิกจริงในคลาสพื้นฐานไม่จำเป็นต้องใช้แล้ว ในข้อ 12.2.3 ได้มีการพูดถึงการสร้างคลาสพื้นฐาน และแต่ละคลาสย่อย ได้อธิบายถึงโครงสร้างบ้างอย่าง ที่คลาสย่อยแต่ละคลาสหลักจะมีเมธอด Draw แต่ไม่มีเมธอดที่ถูกใช้ในคลาสพื้นฐาน ดังนั้น Draw จึงเป็น virtual function ในคลาส

คลาสใดๆ ที่มี virtual function เป็นถือว่าเป็น **abstract class** ใน C++ abstract class จะไม่ถูกทำเครื่องหมายด้วยคำสงวน abstract class จะมีวิธีการกำหนดไว้อย่างสมบูรณ์อยู่แล้ว เนื่องจากการมีอยู่ของ virtual function อย่างน้อยหนึ่งฟังก์ชันเป็นการสร้างอินสแตนซ์ abstract class จะถูกใช้เพื่อแสดงลักษณะของ Type เท่านั้น C++ จะจัดเตรียม abstract class เพื่อสร้างโมเดลคลาสเปล่าๆไว้ หากคลาสย่อยของ abstract class ไม่ได้กำหนดฟังก์ชันของคลาสพาเรนต์ไว้ ฟังก์ชันนั้นจะยังคงเป็น virtual function ในคลาสย่อยต่อไป และคลาสย่อยก็จะเป็น abstract class ไปด้วย

Abstract class และการสืบทอดร่วมกันเพื่อการพัฒนาซอฟต์แวร์ ด้วยการอนุญาตให้กำหนด Type ตามลำดับชั้นเพื่อให้ Type ที่เกี่ยวข้องสามารถเป็นคลาสย่อยของ abstract class ได้อย่างแท้จริงเพื่อให้กำหนด abstract class ได้

การเชื่อมโยงแบบไดนามิกช่วยให้โค้ดที่ใช้สมาชิก อย่าง draw สามารถเขียนได้ก่อนที่จะเขียน draw ขึ้นมาก่อนทั้งหมด ซึ่งจะสามารถเพิ่มคลาสที่สืบทอดมาได้โดยไม่ต้องเปลี่ยนแปลงโค้ด นี่เป็นคุณลักษณะที่มีประโยชน์อย่างมากของการเขียนโปรแกรมเชิงวัตถุ

การกำหนดการอ้างอิงสำหรับอ็อบเจ็กต์สแต็กไดนามิกจะแตกต่างจากการกำหนดตัวชี้สำหรับอ็อบเจ็กต์แบบไดนามิก ตัวอย่างเช่น พิจารณาโค้ดต่อไปนี้ ซึ่งใช้ลำดับชั้นของคลาสเดียวกันกับตัวอย่างล่าสุด:

```c++
Circle circ;        // Allocate a Circle object on the stack
Rectangle rect;     // Allocate a Rectangle object on
                    // the stack
rect = circ;        // Copies the data member values from
                    // the Circle object
rect.draw();        // Calls the draw from the Rectangle
                    // object
```

กำหนดให้ rect = circ ข้อมูลของสมาชิกจากออบเจ้กต์ที่อ้างอิงโดย circ จะถูกกำหนดให้กับสมาชิกของข้อมูลของออบเจ้กต์ที่อ้างอิงไปโดย rect แต่ rect จะยังคงอ้างอิงออบเจ้กต์ Rectangle ดังนั้นการเรียกให้ลากผ่านออบเจ้กต์ที่อ้างอิงโดย rect จะเป็นของคลาส Rectangle ถ้า rect และ circ เป็นตัวชี้ไปยังออบเจ็กต์ heap-dynamic การกำหนดแบบเดียวกันนี้จะเป็นการกำหนดพอยน์เตอร์ ซึ่งจะทำให้ rect ชี้ไปที่ออบเจกต์ Circle และการเรียกให้ Draw ผ่าน rect จะถูกผูกไว้เป็นแบบไดนามิกกับ Draw ในออบเจกต์ของ Circle