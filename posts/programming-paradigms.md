---
title: 'PROGRAMMING PARADIGMS'
date: 'March 5, 2022'
excerpt: 'กระบวนทัศน์การเขียนโปรแกรม'
cover_image: '/images/posts/img2.jpg'
---

## PROGRAMMING PARADIGMS (กระบวนทัศน์การเขียนโปรแกรม)
### ความคิดของคุณเกี่ยวกับการเขียนโปรแกรมเชิงวัตถุ: ข้อดีและข้อเสีย
อันดับแรก ผมจะอธิบายความหมายของ OOP ที่หลายคนคิดว่าเป็น "เชิงวัตถุ" ซึ่งเป็นคำพ้องมาจากคำว่า "ดี" ถ้าเป็นเช่นนั้น คุณไม่จำเป็นต้องมีสังคมศาสตร์อะไรเลย กุญแจสำคัญในการวางแนวออบเจ้กต์คือการใช้ลำดับชั้น A คลาสที่แสดงเป็น polymorphic ผ่าน virtual function ที่เกือบจะมีระดับเทียบเท่ากัน สำหรับการวางออบเจ้กต์ที่เหมาะสม สิ่งสำคัญคือต้องหลีกเลี่ยงการเข้าถึงข้อมูลในลำดับชั้นนั้นโดยตรง ให้เข้าถึงด้วยการใช้เฉพาะส่วนต่อประสานการทำงานที่ออกแบบมาอย่างดีเท่านั้น

นอกจากความเร็วแล้วการเขียนโปรแกรมเชิงวัตถุมีจุดประสงค์ และก็มีจุดอ่อนที่ชัดเจนเช่นกัน โดยเฉพาะอย่างยิ่ง แนวคิดบางอย่างที่ไม่เหมาะสมกันเองโดยธรรมชาติ อย่าง กลไกต่างๆ ที่สนับสนุนตัวโปรแกรม การตั้งค่าที่เยอะมากเมื่อเทียบกับตัวเลือกอื่นๆ แต่สำหรับการแบ่งเลเยอร์เป็นหลายๆ เลเยอร์ จะง่าย และเร็วขึ้น และมีประสิทธิภาพมากขึ้น ได้หากไม่ต้องมีการเช็คความถูกต้องก่อนรันไทม์ ซึ่งนี้จะเป็นวิธีที่ดีกว่า และมีประสิทธิภาพมากกว่า

### แล้ว C++ เป็น OOP หรือไม่?
C++ รองรับการเขียนโปรแกรมที่หลากหลาย รวมถึง OOP ด้วย และการเขียนโปรแกรมทั่วไป การเขียนโปรแกรมเชิงขั้นตอน-โดยการรวมกันของการเขียนโปรแกมเหล่านี้จึงเกิดเป็นภาษาเขียนโปรแกรมที่มีความหลายหลาย และสนับสนุนรูปแบบการเขียนโปรแกรมมากกว่าหนึ่งรูปแบบ ("แบบฟอร์ม") และการเขียนแบบผสมผสานของรูปแบบต่างๆ ได้

### คุณมีตัวอย่างคล่าวๆ เกี่ยวกับการเขียนโปรแกรมหลายกระบวนทัศน์ไหม?
ลองพิจารณาตัวอย่าง "collection of shapes" สุดคลาสสิกนี้ (ตั้งแต่ภาษาเริ่มแรกจนถึงการเขียนโปรแกรมเชิงวัตถุได้รับการสนับสนุน: Simula 67):

```c++
void draw_all(const vector<Shape*>& vs)
{
    for (int i = 0; i<vs.size(); ++i)
        vs[i]->draw();
}
```

ทีนี่ ผมจะใช้ container vector ทั่วไปร่วมกับรูปร่างแบบโพลีมอร์ฟิค โดยที่ vector จะให้ความปลอดภัย และประสิทธิภาพในการทำงานที่เหมาะสมที่สุด Shape จะให้ความสามารถในการจัดการกับรูปร่าง (เช่น วัตถุใดๆ ของคลาสที่ได้มาจาก Shape) โดยไม่ต้องคอมไพล์ใหม่

เราสามารถนำไปใช้กับคอนเทนเนอร์ใดๆ ก็ได้ที่ตรงตามข้อกำหนดของไลบรารีมาตรฐาน C++ ได้อย่างง่ายดาย:

```c++
template<class C> void draw_all(const C& c)
{
    typedef typename C::
        const_iterator CI;
    for (CI p = c.begin();
        p!=c.end(); ++p)
        (*p)->draw();
}
```

ด้วยการวนซ้ำ(loop) เราสามารถใช้ draw_all() นี้กับคอนเทนเนอร์ที่ไม่รองรับอาร์เรย์ได้ เช่น B. รายการไลบรารีมาตรฐาน:

```c++
vector<Shape*> vs;
list<Shape*> ls;
// . . .
draw_all(vs);
draw_all(ls);
```

เรายังสามารถเขียนเพิ่มเติมได้ถึงลำดับที่สร้างตัววนซ้ำซ้อนกัน 2 ตัวเพื่อประมวลผลได้ด้วย:

```c++
template<class Iterator> void draw_all(Iterator b, Iterator e)
{
    for_each(b,e,mem_fun(&Shape::draw));
}
```

เพื่อให้ใช้งานได้ง่ายขึ้น ผมใช้อัลกอริธึม for_each ของไลบรารีมาตรฐานเข้ามาช่วย

เราอาจสามารถเรียก draw_all() ว่าเป็นเวอร์ชันสุดท้ายของรายการไลบรารีมาตรฐานและ
อาร์เรย์ก็ได้:

```c++
list<Shape*> ls;
Shape* as[100];
// . . .
draw_all(ls.begin(),ls.end());
draw_all(as,as+100);
```